template [T] struct vectorTemplate {
  data : T ptr;
  size : int;

  func findMax() : T {
    max : T = 0;
    for (i : int = 0; i < arr->size; ++i) {
      if (this->data[i] > max) {
        max = arr[i];
      }
    }
    return max;
  }

  func findMin(): T {
    min : T = 0;
    for (i : int = 0; i < arr->size; ++i) {
      if (this->data[i] < min) {
        min = arr[i];
      }
    }
    return min;
  }
}

func main(): int {
  {
    arraySize: int = 9;
    data: int ptr = [-3 , 23, 21, 554, 3, 6, -234, 123, 43];
    vector: intVector;
    vector.arr = data;
    vector.size = arraySize;
    max: int = vector.findMax();
    min: int = vector.findMin();
    print(max);
    print('\n');
    print(min);
  }

  {
    arraySize: int = 4;
    data: double ptr = [-3.4, 23.2, 21.3, 43.8];
    vector: intVector;
    vector.arr = data;
    vector.size = arraySize;
    max : double = vector.findMax();
    min: double = vector.findMin();
    print(max);
    print("\n");
    print(min);
  }

}

func getType(type: Type ref): Token {
  tp: Token = tokenizer.peekNext();
  prev: TokenList ptr = nullptr;
  curr: TokenList ptr = @type.tokens;
  while (tp.type != TokenType.END_OF_FILE) {
    if (isTypeDelimiter(tp.type)) {
      if (curr->next) {
        memPool.release(curr->next);
        curr->next = nullptr;
      }
      if (curr && curr->curr.type == TokenType.NOTHING) {
        prev->next = nullptr;
        memPool.release(curr);
      }
      break;
    }
    tokenizer.consumePeek();
    curr->curr = tp;
    curr->next = memPool.getTokenList();
    prev = curr;
    curr = curr->next;
    tp = tokenizer.peekNext();
  }
  return tp;
}
